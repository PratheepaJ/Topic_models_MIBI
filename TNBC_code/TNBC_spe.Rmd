---
title: "TNBC_spe"
output: pdf_document
date: "2022-11-09"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


## Libaries
```{r, warning=FALSE, message=FALSE}
library(readr)
library(dplyr)
library(tidyverse)
library(SpatialExperiment)
```


## Reading the CSV output

```{r}
TNBC <- readr::read_csv("/Users/henzhwang/Desktop/TNBC_training/MIBI-TNBC_scdata_counts_mm_matlab_revised.csv")
```


## Diagnostic of the TNBC dataset

```{r}
# dimension of the TNBC dataset
dim(TNBC)

# number of sample_id and patient_id in the dataset
num_sample_id <- length(unique(TNBC$sample_id))
num_patient_id <- length(unique(TNBC$patient_id))
all.equal(num_sample_id, num_patient_id)
print(paste("There are", num_sample_id, "sample_id and patient_id in the datset."))

# number of cluster_id in the dataset
print(paste("There are", length(unique(TNBC$cluster_id)), "cluster_id in the datset."))
list(sort(unique(TNBC$cluster_id)))

# check to see how many unique cell_type and mm in the datset
print(paste("There are", length(unique(TNBC$cell_type)), 
            "cell_type in the dataset,", "\n", 
            "they are", list(unique(TNBC$cell_type))))

print(paste("There are", length(unique(TNBC$mm)), 
            "cell_type in the dataset,", "\n", 
            "they are", list(unique(TNBC$mm))))
```


```{r, message=FALSE}
# check to see if patient_id is unique to sample_id
TNBC_grouped_sampleId <- TNBC %>% group_by(sample_id)

TNBC_grouped_sampleId %>% 
  summarise(n = n(), 
            num_unique_patient = length(unique(patient_id)), patient_id = unique(patient_id),
            num_unique_image = length(unique(ImageNb)), ImageNb = unique(ImageNb)) #Image 22 and 38 are not included

print(paste("Each patient_id is unqiue to one sample_id.")) # patien_id and sample_id are redundant


# check to see if cell_type and mm are unique to each other
TNBC %>% 
  group_by(mm) %>% 
  summarise(n = n(),
            num_unique_cellType = length(unique(cell_type)), cell_type = unique(cell_type))

print(paste("Each cell_type is unqiue to one mm type."))


# Check number of clusters_id from FlowSOM for each sample
TNBC_grouped_sampleId %>% 
  summarise(n = n(),
            num_unique_cluster = length(unique(cluster_id)))


# check to see how many cell_type in each cluster_id
TNBC %>% 
  group_by(cluster_id) %>% 
  summarise(n = n(),
            num_unique_cellType = length(unique(mm)), # mm and cell_type are the same
            cell_type_1 = as.character(as.list(unique(mm))[1]), 
            cell_type_2 = as.character(as.list(unique(mm))[2]))
```


## Construct assay for TNBC spatial experiment object

### Test case with sample_id 1 and sample_id 2

The goal is create a count matrix with row names are `sample_id` and column names are `cluster_id` where the input values are the count of cells for cluster_id in one sample.

First we want to take sample 1 and try to construct the count matrix.
```{r}
# filter out sample 1 from the TNBC dataset
TNBC_sample1 <- TNBC %>% dplyr::filter(sample_id == 1)
head(TNBC_sample1)

# # select the required columns
# TNBC_sample1 <- TNBC_sample1 %>% 
#   select(c(sample_id, cluster_id, mm, cellLabelInImage, cellSize, cellRadius, centroidX, centroidY))
# head(TNBC_sample1)

# construct count matrix
count_sample1 <- TNBC_sample1 %>% 
  group_by(cluster_id) %>% 
  summarise(sample_1 = n()) %>% 
  #t() %>% 
  as.data.frame()
```


We then want to take sample 2 and construct the count matrix
```{r}
# filter out sample 1 from the TNBC dataset
TNBC_sample2 <- TNBC %>% dplyr::filter(sample_id == 2)
head(TNBC_sample2)

# construct count matrix
count_sample2 <- TNBC_sample2 %>% 
  group_by(cluster_id) %>% 
  summarise(sample_2 = n()) %>% 
  as.data.frame()
```


We then want to join the two dataframe together,
```{r}
# fully joining the count matrix of sample_1 and sample_2
## let cluster_id be the rownames and take transpose(cluster_id as column name)
example <- full_join(x = count_sample1, y = count_sample2, by = "cluster_id") %>% 
  arrange(cluster_id) %>% 
  tibble::column_to_rownames(var = "cluster_id") %>% 
  t() %>% as.data.frame()

# setting NA value in the dataframe to 0
example[is.na(example)] <- 0
example
```

### Application to create count matrix

Now we want to apply the above test case of sample_1 and sample_2 to the whole TNBC dataset. We will write a function `create_countMat()` which takes the dataset as an argument and return a count matrix of all sample_id for the input dataset.

The function performs its functionality by the following steps:

  1. The function takes in the dataset and creates two lists consists all unique sample_id and cluster_id in the dataset and names as `sampleID_list` and `clusterId_list` correspondingly
  2. It uses for loop of the length of the `sampleId_list`. For each `sample_id`, it groups the cell by `cluster_id` and counts the number of them
  3. Next is to fully join all samples count matrix `count.matrix` into one data frame by `cluster_id` and sort them by `cluster_id` in ascending order
  4. The function then compares if `cluster_id` in `count.matrix` has all the same elements of cluster number as in `clusterId_list.
  5. If step 4 is true, then `cluster_id` will become the row names of `count.matrix`. By taking transpose, the `count.matrix` will have `sample_id` as row names and `cluster_id` as column names. `NA` value will be replaced by $0$. Else, the function stops and raises an error
  6. The function returns the count matrix `count.matrix`

```{r}
# write a for loop to create the count matrix of cluster_id for each samples for all sample_id
create_countMat <- function(dataset) {
  
  # lists of unique sample_id and cluster_id
  sampleId_list <- sort(unique(dataset$sample_id))
  #sampleId_list <- 1:2
  clusterId_list <- sort(unique(dataset$cluster_id))
  
  # for loop to create count matrix for each sample_id
  for (k in sampleId_list) {
    sampleId <- paste0("sample_", k)
    
    sample_df <- dataset %>%
      dplyr::filter(sample_id == k) %>% 
      group_by(cluster_id) %>% 
      summarise(!!(sampleId) := n())
      #summarise(!!as.character(k) := n())
      
    if (k == 1) {
      count.matrix <- sample_df
      # !! indicates evaluate; := indicates assign
      #count.matrix <- sample_df %>% dplyr::rename(!!paste0("sample_", k) := counts)
    } else {
      count.matrix <- dplyr::full_join(x = count.matrix,
                                       y = sample_df,
                                       by = "cluster_id") %>% 
        arrange(cluster_id)
    }
    
  }
  #print(clusterId_list)
  #print(count.matrix$cluster_id)
  
  #print(isTRUE(all.equal(count.matrix$cluster_id, clusterId_list)))
  
  if (isTRUE(all.equal(count.matrix$cluster_id, clusterId_list))) {
    count.matrix <- count.matrix %>%
      tibble::column_to_rownames(var = "cluster_id") %>%
      t() %>% as.data.frame() 
    
    # setting NA value in the count matrix to 0
    count.matrix[is.na(count.matrix)] <- 0
  } else {
    stop("Error in counting cluster_id")
  }
  
  return(count.matrix)
}
```

**Test Case:** We subset the `TNBC` dataset with `sample_id` less than or equal to 2 (where is the same dataset used to create the `example`), create its count matrix and compare with `example` data frame.

```{r}
TNBC_12 <- TNBC %>% dplyr::filter(sample_id <= 2)
test <- create_countMat(TNBC_12)

head(test)
all.equal(test, example) 
```
As results shown, `test` count matrix is the same count matrix as `example` count matrix.

Now, we want to apply `create_countMat()` to the `TNBC` dataset.
```{r}
test_all <- create_countMat(TNBC)
dim(test_all)
sum(test_all)
all.equal(length(rownames(test_all)), length(unique(TNBC$sample_id)))
all.equal(as.numeric(gsub("sample_", "", rownames(test_all))), sort(unique(TNBC$sample_id)))
head(test_all)
```

By the above results, we have create a `test_all` count matrix with dimension of $39$ rows(samples) and $113$ columns(cluster_id) with $179194$ cells.


### Simple method

We can construct the count matrix with using one line of code.
```{r}
test_simple <- as.data.frame.matrix(with(TNBC, table(sample_id, cluster_id)))
all.equal(test_simple, test_all) # error is because the row names are different

rownames(test_simple) <- paste0("sample_", rownames(test_simple))
all.equal(test_simple, test_all)
```

